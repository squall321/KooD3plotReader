/**
 * @file KeywordExporter.cpp
 * @brief Implementation of LS-DYNA keyword file exporter
 */

#include "kood3plot/export/KeywordExporter.h"
#include <sstream>
#include <iomanip>
#include <cmath>

namespace kood3plot {
namespace export_utils {

KeywordExporter::KeywordExporter(const data::Mesh& mesh)
    : mesh_(mesh) {
}

bool KeywordExporter::exportState(const data::StateData& state,
                                   const std::string& filename,
                                   const KeywordExportOptions& options) {
    std::ofstream ofs(filename);
    if (!ofs.is_open()) {
        last_error_ = "Failed to open file: " + filename;
        return false;
    }

    // For stress formats, check solid_data instead of displacements
    bool is_stress_format = (options.format == KeywordFormat::INITIAL_STRESS_SOLID ||
                             options.format == KeywordFormat::ELEMENT_STRESS_CSV);

    if (is_stress_format) {
        if (state.solid_data.empty()) {
            last_error_ = "No solid element data in state";
            return false;
        }
    } else {
        // Check displacement data for other formats
        if (state.node_displacements.empty()) {
            last_error_ = "No displacement data in state";
            return false;
        }

        size_t num_nodes = mesh_.nodes.size();
        if (state.node_displacements.size() < num_nodes * 3) {
            last_error_ = "Displacement data size mismatch";
            return false;
        }
    }

    // Write header
    writeHeader(ofs, options, state.time);

    // Write data based on format
    switch (options.format) {
        case KeywordFormat::NODE_DEFORMED:
            writeNodeDeformed(ofs, state, options);
            break;
        case KeywordFormat::NODE_DISPLACEMENT:
            writeNodeDisplacement(ofs, state, options);
            break;
        case KeywordFormat::INITIAL_VELOCITY:
            writeInitialVelocity(ofs, state, options);
            break;
        case KeywordFormat::INITIAL_STRESS_SOLID:
            writeInitialStressSolid(ofs, state, options);
            break;
        case KeywordFormat::ELEMENT_STRESS_CSV:
            writeElementStressCSV(ofs, state, options);
            break;
        default:
            writeNodeDeformed(ofs, state, options);
            break;
    }

    // Write end (except for CSV format)
    if (options.include_end && options.format != KeywordFormat::ELEMENT_STRESS_CSV) {
        ofs << "*END\n";
    }

    ofs.close();
    return true;
}

int KeywordExporter::exportAllStates(const std::vector<data::StateData>& states,
                                      const std::string& base_filename,
                                      const KeywordExportOptions& options) {
    int count = 0;

    // Extract base name and extension
    std::string base = base_filename;
    std::string ext = ".k";
    size_t dot_pos = base_filename.rfind('.');
    if (dot_pos != std::string::npos) {
        base = base_filename.substr(0, dot_pos);
        ext = base_filename.substr(dot_pos);
    }

    // Determine which states to export
    std::vector<size_t> indices_to_export;
    if (options.all_states) {
        for (size_t i = 0; i < states.size(); ++i) {
            indices_to_export.push_back(i);
        }
    } else {
        for (int idx : options.state_indices) {
            if (idx >= 0 && static_cast<size_t>(idx) < states.size()) {
                indices_to_export.push_back(static_cast<size_t>(idx));
            }
        }
    }

    // Export each state
    for (size_t idx : indices_to_export) {
        std::ostringstream oss;
        oss << base << "_" << std::setfill('0') << std::setw(4) << (idx + 1) << ext;

        if (exportState(states[idx], oss.str(), options)) {
            ++count;
        }
    }

    return count;
}

bool KeywordExporter::exportCombined(const std::vector<data::StateData>& states,
                                      const std::string& filename,
                                      const KeywordExportOptions& options) {
    std::ofstream ofs(filename);
    if (!ofs.is_open()) {
        last_error_ = "Failed to open file: " + filename;
        return false;
    }

    // Write main header
    if (options.include_header) {
        ofs << "*KEYWORD\n";
        ofs << "$# LS-DYNA Keyword File - Combined States Export\n";
        ofs << "$# Generated by KooD3plot\n";
        if (!options.title.empty()) {
            ofs << "$# Title: " << options.title << "\n";
        }
        ofs << "$# Total States: " << states.size() << "\n";
        ofs << "$\n";
    }

    // Determine which states to export
    std::vector<size_t> indices_to_export;
    if (options.all_states) {
        for (size_t i = 0; i < states.size(); ++i) {
            indices_to_export.push_back(i);
        }
    } else {
        for (int idx : options.state_indices) {
            if (idx >= 0 && static_cast<size_t>(idx) < states.size()) {
                indices_to_export.push_back(static_cast<size_t>(idx));
            }
        }
    }

    // Export each state with time marker
    for (size_t idx : indices_to_export) {
        const auto& state = states[idx];

        // Time marker comment
        ofs << "$\n";
        ofs << "$# ================================================================\n";
        ofs << "$# State " << (idx + 1) << " / Time = "
            << std::fixed << std::setprecision(7) << state.time << " sec\n";
        ofs << "$# ================================================================\n";
        ofs << "$\n";

        // Write data
        switch (options.format) {
            case KeywordFormat::NODE_DEFORMED:
                writeNodeDeformed(ofs, state, options);
                break;
            case KeywordFormat::NODE_DISPLACEMENT:
                writeNodeDisplacement(ofs, state, options);
                break;
            case KeywordFormat::INITIAL_VELOCITY:
                writeInitialVelocity(ofs, state, options);
                break;
            default:
                writeNodeDeformed(ofs, state, options);
                break;
        }
    }

    // Write end
    if (options.include_end) {
        ofs << "*END\n";
    }

    ofs.close();
    return true;
}

void KeywordExporter::writeHeader(std::ofstream& ofs,
                                   const KeywordExportOptions& options,
                                   double time) {
    if (options.include_header) {
        ofs << "*KEYWORD\n";
        ofs << "$# LS-DYNA Keyword File - Displacement Export\n";
        ofs << "$# Generated by KooD3plot\n";
        if (!options.title.empty()) {
            ofs << "$# Title: " << options.title << "\n";
        }
        if (time >= 0.0) {
            ofs << "$# Time: " << std::fixed << std::setprecision(7) << time << " sec\n";
        }
        ofs << "$\n";
    }
}

void KeywordExporter::writeNodeDeformed(std::ofstream& ofs,
                                         const data::StateData& state,
                                         const KeywordExportOptions& options) {
    ofs << "*NODE\n";
    ofs << "$#   nid               x               y               z      tc      rc\n";

    size_t num_nodes = mesh_.nodes.size();
    const auto& disp = state.node_displacements;

    for (size_t i = 0; i < num_nodes; ++i) {
        int32_t nid = getRealNodeId(i);

        double x, y, z;
        if (options.IU == 1) {
            // IU=1: state data contains absolute coordinates (deformed positions)
            x = disp[i * 3 + 0];
            y = disp[i * 3 + 1];
            z = disp[i * 3 + 2];
        } else {
            // IU=2: state data contains displacements, add to initial
            x = mesh_.nodes[i].x + disp[i * 3 + 0];
            y = mesh_.nodes[i].y + disp[i * 3 + 1];
            z = mesh_.nodes[i].z + disp[i * 3 + 2];
        }

        // Format: nid (8), x (16), y (16), z (16), tc (8), rc (8)
        ofs << std::setw(8) << nid
            << formatNumber(x, 16, options.precision, options.use_scientific)
            << formatNumber(y, 16, options.precision, options.use_scientific)
            << formatNumber(z, 16, options.precision, options.use_scientific)
            << std::setw(8) << 0
            << std::setw(8) << 0
            << "\n";
    }
}

void KeywordExporter::writeNodeDisplacement(std::ofstream& ofs,
                                             const data::StateData& state,
                                             const KeywordExportOptions& options) {
    ofs << "*NODE\n";
    ofs << "$# Displacement values (Ux, Uy, Uz) stored as coordinates\n";
    ofs << "$#   nid              Ux              Uy              Uz      tc      rc\n";

    size_t num_nodes = mesh_.nodes.size();
    const auto& disp = state.node_displacements;

    for (size_t i = 0; i < num_nodes; ++i) {
        int32_t nid = getRealNodeId(i);

        double ux, uy, uz;
        if (options.IU == 1) {
            // IU=1: state data contains coordinates, compute displacement
            ux = disp[i * 3 + 0] - mesh_.nodes[i].x;
            uy = disp[i * 3 + 1] - mesh_.nodes[i].y;
            uz = disp[i * 3 + 2] - mesh_.nodes[i].z;
        } else {
            // IU=2: state data contains displacements directly
            ux = disp[i * 3 + 0];
            uy = disp[i * 3 + 1];
            uz = disp[i * 3 + 2];
        }

        ofs << std::setw(8) << nid
            << formatNumber(ux, 16, options.precision, options.use_scientific)
            << formatNumber(uy, 16, options.precision, options.use_scientific)
            << formatNumber(uz, 16, options.precision, options.use_scientific)
            << std::setw(8) << 0
            << std::setw(8) << 0
            << "\n";
    }
}

void KeywordExporter::writeInitialVelocity(std::ofstream& ofs,
                                            const data::StateData& state,
                                            const KeywordExportOptions& options) {
    ofs << "*INITIAL_VELOCITY_NODE\n";
    ofs << "$# Using displacement data as pseudo-velocity for visualization\n";
    ofs << "$#   nid              vx              vy              vz\n";

    size_t num_nodes = mesh_.nodes.size();
    const auto& disp = state.node_displacements;

    for (size_t i = 0; i < num_nodes; ++i) {
        int32_t nid = getRealNodeId(i);

        double ux, uy, uz;
        if (options.IU == 1) {
            // IU=1: state data contains coordinates, compute displacement
            ux = disp[i * 3 + 0] - mesh_.nodes[i].x;
            uy = disp[i * 3 + 1] - mesh_.nodes[i].y;
            uz = disp[i * 3 + 2] - mesh_.nodes[i].z;
        } else {
            // IU=2: state data contains displacements directly
            ux = disp[i * 3 + 0];
            uy = disp[i * 3 + 1];
            uz = disp[i * 3 + 2];
        }

        ofs << std::setw(8) << nid
            << formatNumber(ux, 16, options.precision, options.use_scientific)
            << formatNumber(uy, 16, options.precision, options.use_scientific)
            << formatNumber(uz, 16, options.precision, options.use_scientific)
            << "\n";
    }
}

void KeywordExporter::writeInitialStressSolid(std::ofstream& ofs,
                                                const data::StateData& state,
                                                const KeywordExportOptions& options) {
    ofs << "*INITIAL_STRESS_SOLID\n";
    ofs << "$# Solid element stress data\n";
    ofs << "$#     eid    nplane    npt   nhisv   large     ipa\n";

    const auto& solid_data = state.solid_data;
    int32_t nv3d = options.NV3D;
    size_t num_solids = options.num_solids;

    // Calculate number of solids from data size if not provided
    if (num_solids == 0 && nv3d > 0) {
        num_solids = solid_data.size() / nv3d;
    }

    // For each solid element
    for (size_t i = 0; i < num_solids; ++i) {
        int32_t eid = getRealSolidId(i);
        size_t offset = i * nv3d;

        // Check bounds
        if (offset + nv3d > solid_data.size()) {
            break;
        }

        // Card 1: eid, nplane (1), npt (1 integration point), nhisv (0), large (0)
        ofs << std::setw(10) << eid
            << std::setw(10) << 1    // nplane
            << std::setw(10) << 1    // npt (1 integration point)
            << std::setw(10) << 0    // nhisv
            << std::setw(10) << 0    // large
            << std::setw(10) << 0    // ipa
            << "\n";

        // Card 2: sigxx, sigyy, sigzz, sigxy, sigyz, sigzx
        // Standard NV3D=7 layout: sigxx, sigyy, sigzz, sigxy, sigyz, sigzx, eps
        double sigxx = solid_data[offset + 0];
        double sigyy = solid_data[offset + 1];
        double sigzz = solid_data[offset + 2];
        double sigxy = solid_data[offset + 3];
        double sigyz = solid_data[offset + 4];
        double sigzx = solid_data[offset + 5];

        ofs << formatNumber(sigxx, 16, options.precision, options.use_scientific)
            << formatNumber(sigyy, 16, options.precision, options.use_scientific)
            << formatNumber(sigzz, 16, options.precision, options.use_scientific)
            << formatNumber(sigxy, 16, options.precision, options.use_scientific)
            << formatNumber(sigyz, 16, options.precision, options.use_scientific)
            << formatNumber(sigzx, 16, options.precision, options.use_scientific)
            << "\n";

        // Card 3: eps (effective plastic strain) - only if NV3D >= 7
        if (nv3d >= 7) {
            double eps = solid_data[offset + 6];
            ofs << formatNumber(eps, 16, options.precision, options.use_scientific)
                << "\n";
        }
    }
}

void KeywordExporter::writeElementStressCSV(std::ofstream& ofs,
                                              const data::StateData& state,
                                              const KeywordExportOptions& options) {
    // CSV header
    ofs << "ElementID,SigXX,SigYY,SigZZ,SigXY,SigYZ,SigZX";
    if (options.NV3D >= 7) {
        ofs << ",EffPlasticStrain";
    }
    ofs << "\n";

    const auto& solid_data = state.solid_data;
    int32_t nv3d = options.NV3D;
    size_t num_solids = options.num_solids;

    // Calculate number of solids from data size if not provided
    if (num_solids == 0 && nv3d > 0) {
        num_solids = solid_data.size() / nv3d;
    }

    // For each solid element
    for (size_t i = 0; i < num_solids; ++i) {
        int32_t eid = getRealSolidId(i);
        size_t offset = i * nv3d;

        // Check bounds
        if (offset + nv3d > solid_data.size()) {
            break;
        }

        // Output stress components
        ofs << eid;
        for (int j = 0; j < std::min(nv3d, 7); ++j) {
            ofs << "," << std::setprecision(options.precision) << solid_data[offset + j];
        }
        ofs << "\n";
    }
}

std::string KeywordExporter::formatNumber(double value, int width, int precision, bool scientific) const {
    std::ostringstream oss;

    if (scientific) {
        oss << std::setw(width) << std::scientific << std::setprecision(precision) << value;
    } else {
        oss << std::setw(width) << std::fixed << std::setprecision(precision) << value;
    }

    return oss.str();
}

int32_t KeywordExporter::getRealNodeId(size_t index) const {
    // Use real node IDs if available, otherwise use 1-based index
    if (!mesh_.real_node_ids.empty() && index < mesh_.real_node_ids.size()) {
        return mesh_.real_node_ids[index];
    }
    return static_cast<int32_t>(index + 1);
}

int32_t KeywordExporter::getRealSolidId(size_t index) const {
    // Use real solid IDs if available, otherwise use 1-based index
    if (!mesh_.real_solid_ids.empty() && index < mesh_.real_solid_ids.size()) {
        return mesh_.real_solid_ids[index];
    }
    return static_cast<int32_t>(index + 1);
}

} // namespace export_utils
} // namespace kood3plot
